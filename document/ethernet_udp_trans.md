<!-- =====================================================================
* Copyright (c) 2023, MongooseOrion.
* All rights reserved.
*
* The following code snippet may contain portions that are derived from
* OPEN-SOURCE communities, and these portions will be licensed with: 
*
* <NULL>
*
* If there is no OPEN-SOURCE licenses are listed, it indicates none of
* content in this Code document is sourced from OPEN-SOURCE communities. 
*
* In this case, the document is protected by copyright, and any use of
* all or part of its content by individuals, organizations, or companies
* without authorization is prohibited, unless the project repository
* associated with this document has added relevant OPEN-SOURCE licenses
* by github.com/MongooseOrion. 
*
* Please make sure using the content of this document in accordance with 
* the respective OPEN-SOURCE licenses. 
* 
* THIS CODE IS PROVIDED BY https://github.com/MongooseOrion. 
* FILE ENCODER TYPE: GBK
* ========================================================================
-->
# 以太网 UDP 传输协议

以太网标准通信模型为 OSI，这是一个 8 层模型。后续在一定程度上参考了 OSI 模型后，产生了 TCP/IP 协议，它简化为 5 层，如下图所示。

<div align='center'><img src='.\pic\Enet003.png' width='600px'></div>

若要使用 FPGA 通过以太网发送数据，有效数据将从传输层开始被处理。下述按照 FPGA 数据发送方向的逻辑来介绍每一个层级。

## 传输层

传输层有两种传输协议：基于字节流的 TCP 协议、基于报文流的 UDP 协议。两种协议各有优缺点，应用于不同场景。TCP 协议是**面向连接**的流传输协议，可以保证数据传输的**完整、有序**，是**可靠协议**，常用在对数据完整性和正确性要求较高的场合，如文件传输，占用资源较 UDP 多，速度较 UDP 慢。UDP 协议则是一种**无连接**的传输层协议，提供面向事务的**简单不可靠**信息传送服务，因为**无需连接**，传输速度较 TCP 快，占用资源量较 TCP 少，适合实时数据的传输，如视频通话。下面介绍 UDP 传输协议。

<div align='center'><img src='.\pic\屏幕截图 2024-08-10 155033.png' width='300px'></div>

<div align='center'><img src='.\pic\屏幕截图 2024-08-10 155213.png' width='600px'></div>

UDP数据包分为 UDP 首部和有效数据两个部分。UDP 首部由源端口，目的端口，报文长度以及校验和组成。相比TCP，UDP的传输效率更高，开销更小，但是无法保证数据传输可靠性。每个部分的描述见下表：

| 各字段 | 数据宽度 | 描述 |
| :--- | :---: | :--- |
| 源端口号（udp_send_source_port） | 16bit | 源主机的应用程序使用的端口号。 |
| 目的端口号（udp_send_destination_port） | 16bit | 目的主机的应用程序使用的端口号。 |
| UDP 长度（udp_send_data_length） | 16bit | UDP 头部和 UDP 数据的字节长度。因为 UDP 头部长度是 8 字节，所以字段的最小值为 8。 |
| UDP 校验和（checksum） | 16bit | 在 IPv4 中，UDP 校验和是可选的。如果发送方不计算校验和，它可以将校验和字段置为 0，表示不使用校验和。然而在 IPv6 中，UDP 校验和是必需的，不能置 0。 |

### UDP 校验和（checksum）字段计算方法

UDP校验和的计算需要三部分数据：UDP 伪首部、UDP 首部和有效数据。伪首部包含 IP 首部一些字段，这部分不是 UDP 数据包包含的内容，只是参与计算的内容。

如果各字段数据如下：

<div align='center'><img src='.\pic\Enet011.png' width='600px'></div>

则计算方法为：

  1. 将校验和字段 `0092` 置为 `0000`（因为这是需要求解的字段）：

      ```
      a9 fe bf 1f a9 fe 01 17 00 11 00 28 04 d2 04 d2 00 28 00 00 68 74 74 70 3a 2f 2f 77 77 77 2e 63 6d 73 6f 66 74 2e 63 6e 20 51 51 3a 31 30 38 36 35 36 30 30
      ```

  2. 以 2 字节为单位，进行逐段相加：

      ```
      a9fe + bf1f + a9fe + 0117 + 0011 + 0028 + 04d2 + 04d2 + 0028 + 0000 + 6874 + 7470 + 3a2f + 2f77 + 7777 + 2e63 + 6d73 + 6f66 + 742e + 636e + 2051 + 513a + 3130 + 3836 + 3536 + 3030 = 6 ff67
      ```

  3. 如果和大于 16 位，需要将溢出的部分加到结果的最低有效位上（即回卷加法），**直到**最终结果为 16 位数据，将进位 `6` 加到低 16 位 `ff67` 上：

      ```
      6 + ff67 = ff6d
      ```

  4. 将 `ff6d` 取反得 `0092`，即 $\text{checksum}=0092$

### 收方检错方法

对 UDP 数据包中每个 16bit 进行求和，溢出部分使用回卷加法，然后将计算结果再取反码。若结果为 0，通过检验，否则，不通过检验。以上述的数据为例，计算方法为：

  1. 以 2 字节为单位，进行逐段相加：

      ```
      a9fe + bf1f + a9fe + 0117 + 0011 + 0028 + 04d2 + 04d2 + 0028 + 0092 + 6874 + 7470 + 3a2f + 2f77 + 7777 + 2e63 + 6d73 + 6f66 + 742e + 636e + 2051 + 513a + 3130 + 3836 + 3536 + 3030 = 6 fff9
      ```

  2. 应用回卷加法，将进位 `6` 加到低 16 位 `fff9` 上：

      ```
      6 + fff9 = ffff
      ```

  3. 将 `ffff` 取反得 `0`，通过检验。

## 网络层

网络层协议包含 IP、ARP 和 ICMP。在这一层，TCP/UDP 报文段或数据报会被封装进一个 IP 数据包中。IP 协议会为数据添加一个 IP 报头。ARP 和 ICMP 不会对 TCP/UDP 包有效数据进行处理，它们在网络通信中有特定的用途，主要用于网络管理和控制，而不是传输应用层数据。

  * IP：网络层的核心协议，负责将数据包从源地址传送到目的地址。IP 提供了路由选择、地址解析和数据包的封装/拆封等功能。
  * ARP：将 IP 地址解析为物理网络接口的 MAC 地址。在以太网等协议下，当主机需要与同一网络中的另一台主机通信时，它使用 ARP 来确定对方的 MAC 地址，然后才能通过链路层进行通信。
  * ICMP：用于发送网络设备之间的控制消息和错误报告。常见的 ICMP 应用是 `ping` 命令，用于检查目标主机是否可达。

### IP 协议

IP 协议用于将传输层的数据报封装为一个 IP 数据包，IP 协议包括 IPv4 和 IPv6，本文仅介绍 IPv4。IP 包格式如下图所示：

<div align='center'><img src='.\pic\屏幕截图 2024-08-10 164613.png' width='300px'></div>

<div align='center'><img src='.\pic\屏幕截图 2024-08-10 164653.png' width='600px'></div>

数据包是一个可变长分组，有两部分组成：IP 首部和数据。首部长度可由 20~60 个字节组成，该部分包含有与路由选择和传输有关的重要信息。IP 首部各字段的描述如下表所示：

| 各字段 | 数据宽度 | 描述 |
| :--- | :---: | :--- |
| 版本（ip_version） | 4bit | 定义 IP 协议版本，IPv4 -> `4'h4`，IPv6 -> `4'h6` |
| 首部长度（header_len） | 4bit | 该字段定义数据报协议头长度，最大值是 4'h15（1 个单位为 4 字节），一般可直接设置为 `4'h5`。 |
| 服务类型 | 8bit | 定义上层协议对处理当前数据报所期望的服务质量，前3位成为优先位，后面4位成为服务类型，最后1位没有定义。一般直接填 `8'h0`。 |
| 总长度（ip_send_data_length） | 16bit | 定义整个IP数据报的字节长度，包括协议头部和数据。取值范围为 46-1500byte |
| 标识（identify_code） | 16bit | 用于唯一标识 IP 数据包的特定分片。当一个 IP 数据包的大小超过网络的最大传输单元（MTU）时，IP 层需要将该数据包分成多个小的片段进行传输。每个分片都会带有相同的标识字段值，以便接收方能够将这些分片重新组装为原始数据包。在视频传输系统中（mac_test.v）可用于计数行数。 |
| 标记 | 3bit | 用于控制和描述 IP 数据包的分片行为。它包含了 3 位标志，分别是：<br>第 0 位：保留位，通常必须为 0。<br>第 1 位：不分片标志。DF = 1：表示禁止分片。如果数据包超过网络的 MTU 而设置了此标志，路由器将丢弃数据包并发送 ICMP 终点不可达消息给源主机。DF = 0：表示允许分片，数据包可以根据需要被分片。<br>第 2 位：更多分片标志（MF）。MF = 1：表示后面还有更多的分片。如果一个数据包被分成了多个分片，除了最后一个分片外，所有的分片都会设置这个标志位。MF = 0：表示这是数据包的最后一个分片，或者这是一个未分片的单个数据包。|
| 分段偏移 | 13bit | 用于在数据包分片时指示每个分片在原始数据包中的位置。例如，如果一个分片的分段偏移为 3（即以 8 字节为单位计算，则偏移量是 3 × 8 = 24 字节），这表示该分片应该放置在原始数据包的第 24 字节处。 |
| 生存时间（TTL） | 8bit | 当数据包从源主机发出时，源主机会为其设置一个初始的 TTL 值（通常为 64、128 或 255），每经过一个路由器，TTL 值减 1。当 TTL 减至 0 时，路由器会丢弃该数据包，并发送 ICMP 时间超时消息给源主机，通知数据包未能到达目的地。 |
| 协议（ip_send_type） | 8bit | 指出此数据报携带的数据使用何种协议，8'h1 表示为 ICMP 协议，8'h2 表示为 IGMP 协议，8'h6 表示为 TCP 协议，8'h11 表示为 UDP 协议。 |
| 首部校验和 | 16bit | 帮助确保IP协议头的完整性。IPv4 头部校验和是必需的，IPv6 取消了头部校验和字段，因此 IPv6 本身不包含校验和。 |
| 源地址（source_ip_addr） | 32bit | 源主机IP地址。 |
| 目标地址（destination_ip_addr） | 32bit | 目标主机IP地址。 |

#### IP 首部校验和计算方法

此处的首部校验和与 UDP 首部校验和的计算方式一致，假设有：

  1. IP 头部数据：
  
      ```
      45 00 00 30 80 4c 40 00 80 06 b5 2e d3 43 11 7b cb 51 15 3d
      ```

  2. 将校验和字段 `b5 2e` 置为 0，因为这是需要求解的字段，2 字节逐段相加：

      ```
      4500 + 0030 + 804c + 4000 + 8006 + 0000 + d343 + 117b + cb51 + 153d = 3 4ace
      ```

  3. 回卷加法，处理溢出位：

      ```
      0003 + 4ace = 4ad1
      ```

  4. 将 `4ad1` 取反得 `b52e` 。

#### 收方检错方法

与 UDP 检测方法一致：

  1. 将首部字段数据按 2 字节逐段相加：

      ```
      4500 + 0030 + 804c + 4000 + 8006 + b52e + d343 + 117b + cb51 + 153d = 3 fffc
      ```

  2. 处理溢出位：

      ```
      0003 + fffc = ffff
      ```

  3. 取反得 `0`，校验通过。

### ARP 协议 

ARP 是一种用于在同一局域网内解析 IP 地址到 MAC 地址的协议。当一台主机要与同一局域网中的另一台主机通信时，它需要知道目标主机的 MAC 地址，ARP 就是为了解决这个问题而设计的。

当主机 A 需要向同一网络中的主机 B 发送数据时，主机 A 已经知道了目标主机 B 的 IP 地址，但它不知道目标主机的 MAC 地址。主机 A 在自己的 ARP 缓存中查找是否已经有主机 B 的 IP 地址对应的 MAC 地址。如果有，直接使用；如果没有，就需要发送一个ARP请求。

ARP请求是一种广播消息，它将被发送到网络中的所有设备。这条消息包含以下信息：

  * 发送方的 IP 地址和 MAC 地址（主机 A 的 IP 地址和 MAC 地址）。
  * 目标的 IP 地址（主机 B 的 IP 地址）。

请求的内容：主机 A 询问哪个设备持有这个 IP 地址，并请求该设备的 MAC 地址。由于这是广播消息，所有连接到同一局域网的设备都会收到这条消息。

收到 ARP 请求的所有设备会检查消息中的目标 IP 地址。如果某台设备（假设是主机 B）的 IP 地址与请求中的目标 IP 地址匹配，它将生成一个 ARP 响应。ARP 响应是一个单播消息，包含以下信息：

  * 目标 IP 地址和它对应的 MAC 地址（主机 B 的 IP 地址和 MAC 地址）。
  * 发送方的 IP 地址和 MAC 地址（主机 B 的 IP 地址和 MAC 地址）。

这条消息会发送回请求者，即主机 A。

当主机 A 收到主机 B 的 ARP 响应后，它会将主机 B 的 IP 地址和 MAC 地址对保存到 ARP 缓存中，以便将来的通信使用。之后，主机 A 可以使用此 MAC 地址将数据链路层帧直接发送到主机 B。ARP 缓存中的条目并不是永久存在的，通常有一个过期时间（TTL）。当某个条目过期后，它会被删除，如果再次需要通信，就必须发起新的 ARP 请求。

### ICMP 协议 

ICMP 是 TCP/IP 协议族的一个 IP 层子协议，包含在 IP 数据报里，用于 IP 主机、路由器之间传递控制消息。控制消息是指网络是否连通，主机是否可达等功能。ICMP 报文如下图所示：

<div align='center'><img src='.\pic\绘图1.png' width='350px'></div>

报文类型可选值如下表所示，其中 ping 功能采用回送请求和回答报文，回送请求报文类型为 `8'h8`，回答报文类型为 `8'h0`。

| 报文类型 | 值（8bit） | 描述 |
| :---: | :---: | :--- |
| 回送应答 | 8'h0 | 这是 ping 的应答消息。 |
| 终点不可达 | 8'h3 | 表示目标地址无法到达。 |
| 源点抑制 | 8'h4 |  |
| 改变路由 | 8'h5 | 表示路由器发现数据包的最佳路径不是它自己。 |
| 回送请求 | 8'h8 | 这是 ping 的请求消息。 |
| 时间超时 | 8'hb | 表示数据包的 TTL 达到零时的消息。 |

代码字段进一步细化了类型字段，用于指定特定的子类型。例如，对于 “目标不可达” 类型的 ICMP 消息，不同的代码表示不同的原因：

  * 0：网络不可达（Network Unreachable）
  * 1：主机不可达（Host Unreachable）
  * 3：端口不可达（Port Unreachable）

字段 4 的内容根据 ICMP 报文类型不同而变化。例如对于 ping，该字段应该包括一个标识符（icmp_id）和一个序列号（icmp_seq），数据就来自于 icmp_rx_data，各 16 位。

数据部分包含了与特定的 ICMP 消息相关的附加信息，其长度和内容因类型和代码的不同而不同。例如：

  * 对于回送请求和响应，数据部分可以是随意的填充数据，一般用于验证数据的回传。
  * 对于终点不可达和超时报文，数据部分通常包含引起错误的原始 IP 数据包头部和前 8 字节的内容。

## 数据链路层

MAC 子层是属于数据链路层的下半部分，它主要负责与物理层进行数据交接，如是否可以发送数据，发送的数据是否正确，对数据流进行控制等。它自动对来自上层的数据包加上一些控制信号，交给物理层。接收方得到正常数据时，自动去除 MAC 控制信号，把该数据包交给上层。

MAC 数据包（以太网帧数据包）的格式如下图所示：

<div align='center'><img src='.\pic\屏幕截图 2024-08-10 183756.png' width='600px'></div>

MAC 数据包由前导字段、帧起始定界符、目标地址、源地址、数据包类型、数据域、填充域、校验和域组成。各字段描述如下表所示：

| 各字段 | 数据宽度 | 描述 |
| :--- | :---: | :--- |
| 前导字段 | 7Byte | 也称报头，这是一段方波，用于使收发节点的时钟同步。内容为连续 7 个字节的 `0x55`。 |
| 帧起始定界符(SFD) | 1Byte | 用于区分前导段与数据段的，内容为 `0xD5`。 |
| 源 MAC 地址 | 6byte | 源主机 MAC 地址，由 48 位数字组成，它是网卡的物理地址，在同一个网络里不能有两个相同的 MAC 地址。 |
| 目标 MAC 地址 | 6byte | 目标主机 MAC 地址 |
| 数据包类型 | 2Byte | 本区域用来描述本 MAC 数据包是属于 TCP/IP 协议层的 IP 包、 ARP 包还是 SNMP 包。常用的有 0800 表示 IP 协议，0806 表示 ARP 协议，8035 表示 RARP 协议。见 `ip_tx.v` |
| 数据段 | 46-1500byte | 来自网络层，IP、ARP 或 ICMP 的数据包 |
| 填充域 | - | 如果数据段不足 46byte，将数据段填 0 填到 46byte |
| 校验和域 | 4Byte | 它保存了 CRC 校验序列，用于检错。 |

### CRC32 算法

在以太网帧中，CRC32 校验码的计算是从**目标地址（Destination MAC Address）开始逐字节进行的，直到填充域（如果存在）**的最后一个字节。这个过程包括了以下各个字段：

  * 前导字段（Preamble）：7 字节
  * 帧起始定界符（SFD, Start Frame Delimiter）：1 字节
  * 目标地址（Destination MAC Address）：6 字节
  * 源地址（Source MAC Address）：6 字节
  * 类型/长度字段（Type/Length）：2 字节
  * 数据域（Data/Payload）：46 到 1500 字节
  * 填充域（Pad）（可选）：用于确保数据域至少为 46 字节

CRC 数值计算模块可以直接[点此](http://www.easics.com/webtools/crctool)使用工具自动生成。

计算完毕后，对得到的 CRC32 值按位取反，这个结果就是最终的 FCS 字段的数据。

## 介质无关接口

MII （Media Independent Interface，介质无关接口）或称为媒体独立接口，它是 IEEE-802.3 定义的以太网行业标准，用以连接以太网 MAC 层和 PHY 芯片，常用接口有：MII、RMII、SMII、GMII、RGMII。

### MII 和 RMII

